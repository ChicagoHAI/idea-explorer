"""
GitHub Manager - Handles GitHub repository operations

This module manages:
1. Creating repositories in ChicagoHAI organization
2. Cloning repositories locally
3. Committing and pushing changes
4. Creating pull requests (optional)
"""

from pathlib import Path
from typing import Optional, Dict, Any
import os
import subprocess
import shlex
from datetime import datetime

try:
    from github import Github, GithubException
    PYGITHUB_AVAILABLE = True
except ImportError:
    PYGITHUB_AVAILABLE = False
    print("Warning: PyGithub not installed. Install with: pip install PyGithub")

try:
    from git import Repo, GitCommandError
    GITPYTHON_AVAILABLE = True
except ImportError:
    GITPYTHON_AVAILABLE = False
    print("Warning: GitPython not installed. Install with: pip install GitPython")


class GitHubManager:
    """
    Manages GitHub operations for research projects.

    Requires GITHUB_TOKEN environment variable to be set.
    """

    def __init__(self,
                 org_name: str = "ChicagoHAI",
                 token: Optional[str] = None,
                 workspace_dir: Optional[Path] = None):
        """
        Initialize GitHub manager.

        Args:
            org_name: GitHub organization name (default: ChicagoHAI)
            token: GitHub personal access token. If None, reads from GITHUB_TOKEN env var.
            workspace_dir: Directory for cloning repos (default: project_root/workspace)
        """
        self.org_name = org_name

        # Get token from parameter or environment
        self.token = token or os.getenv('GITHUB_TOKEN')
        if not self.token:
            raise ValueError(
                "GitHub token not provided. Either pass token parameter or set GITHUB_TOKEN environment variable."
            )

        # Set workspace directory
        if workspace_dir is None:
            project_root = Path(__file__).parent.parent.parent
            workspace_dir = project_root / "workspace"
        self.workspace_dir = Path(workspace_dir)
        self.workspace_dir.mkdir(exist_ok=True)

        # Initialize PyGithub
        if not PYGITHUB_AVAILABLE:
            raise ImportError("PyGithub is required. Install with: pip install PyGithub")

        self.github = Github(self.token)

        # Get organization
        try:
            self.org = self.github.get_organization(self.org_name)
            print(f"âœ“ Connected to GitHub organization: {self.org_name}")
        except GithubException as e:
            raise ValueError(f"Failed to access organization '{self.org_name}': {e}")

    def create_research_repo(self,
                           idea_id: str,
                           title: str,
                           description: Optional[str] = None,
                           private: bool = False) -> Dict[str, Any]:
        """
        Create a new repository in the organization for research.

        Args:
            idea_id: Unique idea identifier
            title: Research title
            description: Repository description
            private: Whether to make repo private (default: False/public)

        Returns:
            Dictionary with repo information:
            - repo_name: Name of created repository
            - repo_url: HTTPS URL for the repository
            - clone_url: URL for cloning
            - local_path: Local path where repo will be cloned
        """
        # Sanitize repo name (GitHub requirements)
        repo_name = self._sanitize_repo_name(idea_id)

        # Create description
        if description is None:
            description = f"Autonomous research experiment: {title}"

        description += f"\n\nGenerated by Idea Explorer on {datetime.now().strftime('%Y-%m-%d')}"

        print(f"\nðŸ“¦ Creating GitHub repository...")
        print(f"   Organization: {self.org_name}")
        print(f"   Name: {repo_name}")
        print(f"   Visibility: {'Private' if private else 'Public'}")

        try:
            # Create repository
            repo = self.org.create_repo(
                name=repo_name,
                description=description,
                private=private,
                has_issues=True,
                has_wiki=False,
                has_projects=False,
                auto_init=True,  # Create with README
                license_template=None,
                gitignore_template="Python"
            )

            print(f"âœ… Repository created: {repo.html_url}")

            # Wait a moment for repo to be fully initialized
            import time
            time.sleep(2)

            return {
                'repo_name': repo_name,
                'repo_url': repo.html_url,
                'clone_url': repo.clone_url,
                'ssh_url': repo.ssh_url,
                'local_path': self.workspace_dir / repo_name,
                'repo_object': repo
            }

        except GithubException as e:
            if e.status == 422 and 'already exists' in str(e):
                # Repository already exists
                print(f"â„¹ï¸  Repository {repo_name} already exists, using existing repo")
                repo = self.org.get_repo(repo_name)
                return {
                    'repo_name': repo_name,
                    'repo_url': repo.html_url,
                    'clone_url': repo.clone_url,
                    'ssh_url': repo.ssh_url,
                    'local_path': self.workspace_dir / repo_name,
                    'repo_object': repo
                }
            else:
                raise RuntimeError(f"Failed to create repository: {e}")

    def clone_repo(self, clone_url: str, local_path: Path) -> 'Repo':
        """
        Clone repository to local path.

        Args:
            clone_url: HTTPS clone URL
            local_path: Where to clone the repository

        Returns:
            GitPython Repo object
        """
        if not GITPYTHON_AVAILABLE:
            raise ImportError("GitPython is required. Install with: pip install GitPython")

        # Inject token into clone URL for authentication
        auth_url = clone_url.replace('https://', f'https://{self.token}@')

        print(f"\nðŸ“¥ Cloning repository...")
        print(f"   Destination: {local_path}")

        try:
            # Remove if exists
            if local_path.exists():
                import shutil
                shutil.rmtree(local_path)

            # Clone
            repo = Repo.clone_from(auth_url, local_path)
            print(f"âœ… Repository cloned successfully")

            return repo

        except GitCommandError as e:
            raise RuntimeError(f"Failed to clone repository: {e}")

    def commit_and_push(self,
                       repo_path: Path,
                       commit_message: str,
                       branch: str = "main") -> bool:
        """
        Commit all changes and push to GitHub.

        Args:
            repo_path: Path to local repository
            commit_message: Commit message
            branch: Branch name (default: main)

        Returns:
            True if successful
        """
        if not GITPYTHON_AVAILABLE:
            raise ImportError("GitPython is required. Install with: pip install GitPython")

        print(f"\nðŸ“ Committing and pushing changes...")

        try:
            repo = Repo(repo_path)

            # Configure git user (if not set)
            try:
                repo.config_reader().get_value("user", "name")
            except:
                # Set default user
                with repo.config_writer() as git_config:
                    git_config.set_value("user", "name", "Idea Explorer")
                    git_config.set_value("user", "email", "idea-explorer@chicagohai.org")

            # Add all files
            repo.git.add(A=True)

            # Check if there are changes to commit
            if repo.is_dirty(untracked_files=True):
                # Commit
                repo.index.commit(commit_message)
                print(f"   âœ“ Committed: {commit_message}")

                # Configure remote with authentication
                origin = repo.remote('origin')
                origin_url = list(repo.remote('origin').urls)[0]

                # Inject token for push
                if 'https://' in origin_url and self.token not in origin_url:
                    auth_url = origin_url.replace('https://', f'https://{self.token}@')
                    origin.set_url(auth_url)

                # Push
                origin.push(branch)
                print(f"   âœ“ Pushed to {branch}")

                return True
            else:
                print("   â„¹ï¸  No changes to commit")
                return False

        except GitCommandError as e:
            raise RuntimeError(f"Failed to commit and push: {e}")

    def create_summary_pr(self,
                         repo_name: str,
                         title: str,
                         body: str,
                         head_branch: str = "research-results",
                         base_branch: str = "main") -> Optional[str]:
        """
        Create a pull request summarizing research results.

        Args:
            repo_name: Repository name
            title: PR title
            body: PR description
            head_branch: Source branch
            base_branch: Target branch

        Returns:
            PR URL if successful, None otherwise
        """
        try:
            repo = self.org.get_repo(repo_name)

            # Create PR
            pr = repo.create_pull(
                title=title,
                body=body,
                head=head_branch,
                base=base_branch
            )

            print(f"âœ… Pull request created: {pr.html_url}")
            return pr.html_url

        except GithubException as e:
            print(f"âš ï¸  Failed to create pull request: {e}")
            return None

    def get_workspace_path(self, idea_id: str) -> Optional[Path]:
        """
        Get workspace path for an idea if it exists.

        Args:
            idea_id: Idea identifier

        Returns:
            Path to workspace if it exists, None otherwise
        """
        repo_name = self._sanitize_repo_name(idea_id)
        workspace_path = self.workspace_dir / repo_name

        if workspace_path.exists() and (workspace_path / ".git").exists():
            return workspace_path
        return None

    def pull_latest(self, repo_path: Path, branch: str = "main") -> bool:
        """
        Pull latest changes from remote repository.

        Args:
            repo_path: Path to local repository
            branch: Branch name (default: main)

        Returns:
            True if successful
        """
        if not GITPYTHON_AVAILABLE:
            raise ImportError("GitPython is required. Install with: pip install GitPython")

        print(f"\nðŸ“¥ Pulling latest changes from GitHub...")

        try:
            repo = Repo(repo_path)

            # Configure remote with authentication
            origin = repo.remote('origin')
            origin_url = list(origin.urls)[0]

            # Inject token for pull
            if 'https://' in origin_url and self.token not in origin_url:
                auth_url = origin_url.replace('https://', f'https://{self.token}@')
                origin.set_url(auth_url)

            # Pull changes
            origin.pull(branch)
            print(f"   âœ“ Pulled latest changes from {branch}")

            return True

        except GitCommandError as e:
            print(f"   âš ï¸  Warning: Failed to pull changes: {e}")
            print(f"   Continuing with local version...")
            return False

    def _sanitize_repo_name(self, idea_id: str) -> str:
        """
        Sanitize idea ID to valid GitHub repository name.

        Rules:
        - Only alphanumeric, hyphens, and underscores
        - Cannot start/end with hyphen
        - Max 100 characters

        Args:
            idea_id: Idea identifier

        Returns:
            Valid repository name
        """
        # Replace spaces and invalid chars with hyphens
        name = idea_id.lower()
        name = ''.join(c if c.isalnum() or c in ['-', '_'] else '-' for c in name)

        # Remove leading/trailing hyphens
        name = name.strip('-')

        # Limit length
        name = name[:100]

        return name

    def add_research_metadata(self,
                            repo_path: Path,
                            idea_spec: Dict[str, Any]) -> None:
        """
        Add research metadata files to repository.

        Creates:
        - README.md with research overview
        - .idea-explorer/metadata.json with full idea spec

        Args:
            repo_path: Path to local repository
            idea_spec: Idea specification dictionary
        """
        import json
        import yaml

        # Create metadata directory
        metadata_dir = repo_path / ".idea-explorer"
        metadata_dir.mkdir(exist_ok=True)

        # Save full idea spec
        with open(metadata_dir / "idea.yaml", 'w') as f:
            yaml.dump(idea_spec, f, default_flow_style=False, sort_keys=False)

        # Create README
        idea = idea_spec.get('idea', {})

        readme_content = f"""# {idea.get('title', 'Research Experiment')}

**Autonomous research experiment generated by [Idea Explorer](https://github.com/ChicagoHAI/idea-explorer)**

## Research Question

{idea.get('hypothesis', 'No hypothesis specified')}

## Domain

{idea.get('domain', 'unknown').replace('_', ' ').title()}

## Overview

This repository contains an autonomous research experiment where an AI agent:
- Designed the experimental methodology
- Implemented all code
- Ran analyses
- Generated documentation

## Repository Structure

```
notebooks/          # Jupyter notebooks with experiments
  plan_Md.ipynb            # Research plan
  documentation_Md.ipynb   # Results and analysis
  code_walk_Md.ipynb       # Code walkthrough

results/            # Experimental outputs
  metrics.json             # Quantitative results
  *.png                    # Visualizations

.idea-explorer/     # Metadata
  idea.yaml                # Original idea specification
```

## Methodology

{idea.get('methodology', {}).get('approach', 'See plan notebook for details')}

## Expected Outputs

"""

        for output in idea.get('expected_outputs', []):
            readme_content += f"- **{output.get('type', 'output').title()}**: {output.get('description', 'See results/')}\\n"

        readme_content += f"""

## Evaluation Criteria

"""

        for criterion in idea.get('evaluation_criteria', []):
            readme_content += f"- {criterion}\\n"

        readme_content += f"""

## How to Reproduce

1. Review the research plan: `notebooks/plan_Md.ipynb`
2. Follow the code walkthrough: `notebooks/code_walk_Md.ipynb`
3. Execute notebooks in order
4. Compare your results with `results/`

## Citation

If you use this research, please cite:

```bibtex
@misc{{{{idea_explorer_{idea.get('metadata', {}).get('idea_id', 'experiment')}}},
  title={{{{{idea.get('title', 'Research Experiment')}}}}},
  author={{{{Idea Explorer (Autonomous Agent)}}}},
  year={{{{{datetime.now().year}}}}},
  url={{{{https://github.com/{self.org_name}/{self._sanitize_repo_name(idea.get('metadata', {}).get('idea_id', 'experiment'))}}}}}
}}
```

---

**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Organization**: [ChicagoHAI](https://github.com/ChicagoHAI)
**Framework**: [Idea Explorer](https://github.com/ChicagoHAI/idea-explorer)
"""

        with open(repo_path / "README.md", 'w') as f:
            f.write(readme_content)

        print("âœ“ Added research metadata and README")


def main():
    """Test GitHub manager."""
    # This requires GITHUB_TOKEN to be set
    manager = GitHubManager()

    # Test repo creation
    repo_info = manager.create_research_repo(
        idea_id="test_experiment_001",
        title="Test Experiment",
        description="This is a test",
        private=False
    )

    print(f"\nCreated repo: {repo_info['repo_url']}")
    print(f"Clone URL: {repo_info['clone_url']}")
    print(f"Local path: {repo_info['local_path']}")

    # Test cloning
    repo = manager.clone_repo(
        repo_info['clone_url'],
        repo_info['local_path']
    )

    print(f"\nCloned to: {repo.working_dir}")

    # Add test file
    test_file = Path(repo.working_dir) / "test.txt"
    test_file.write_text("Hello from Idea Explorer!")

    # Test commit and push
    manager.commit_and_push(
        Path(repo.working_dir),
        "Add test file"
    )

    print("\nâœ… GitHub integration test complete!")


if __name__ == "__main__":
    main()
